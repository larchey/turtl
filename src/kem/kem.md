## Module-Lattice-Based Key-Encapsulation Mechanism (ML-KEM)

The ML-KEM module provides an implementation of the Module-Lattice-Based Key-Encapsulation Mechanism as specified in NIST FIPS 203. ML-KEM is a post-quantum cryptographic scheme that allows two parties to establish a shared secret key over an insecure channel.

### Key Generation

The `KeyPair` struct represents an ML-KEM key pair, consisting of a public key and a private key. To generate a new key pair, use the `KeyPair::generate` function:

```rust
pub fn generate(parameter_set: ParameterSet) -> Result<KeyPair>
```

- `parameter_set`: The parameter set to use for key generation. Available options are `ParameterSet::ML_KEM_512`, `ParameterSet::ML_KEM_768`, and `ParameterSet::ML_KEM_1024`.
- Returns: A `Result` containing the generated `KeyPair` on success, or an `Error` if key generation fails.

Example usage:
```rust
let keypair = KeyPair::generate(ParameterSet::ML_KEM_768)?;
```

You can also create a key pair from an existing seed using the `KeyPair::from_seed` function:

```rust
pub fn from_seed(seed: &[u8], parameter_set: ParameterSet) -> Result<KeyPair>
```

- `seed`: A 32-byte seed value used to deterministically generate the key pair.
- `parameter_set`: The parameter set to use for key generation.
- Returns: A `Result` containing the generated `KeyPair` on success, or an `Error` if key generation fails.

Example usage:
```rust
let seed = [0u8; 32];
let keypair = KeyPair::from_seed(&seed, ParameterSet::ML_KEM_512)?;
```

### Encapsulation

The `encapsulate` function is used to generate a shared secret and its corresponding ciphertext using a public key:

```rust
pub fn encapsulate(public_key: &PublicKey) -> Result<(Ciphertext, SharedSecret)>
```

- `public_key`: The public key used for encapsulation.
- Returns: A `Result` containing a tuple of the generated `Ciphertext` and `SharedSecret` on success, or an `Error` if encapsulation fails.

Example usage:
```rust
let (ciphertext, shared_secret) = kem::encapsulate(&keypair.public_key())?;
```

### Decapsulation

The `decapsulate` function is used to decapsulate a ciphertext and retrieve the shared secret using a private key:

```rust
pub fn decapsulate(private_key: &PrivateKey, ciphertext: &Ciphertext) -> Result<SharedSecret>
```

- `private_key`: The private key used for decapsulation.
- `ciphertext`: The ciphertext to be decapsulated.
- Returns: A `Result` containing the decapsulated `SharedSecret` on success, or an `Error` if decapsulation fails.

Example usage:
```rust
let decapsulated_secret = kem::decapsulate(&keypair.private_key(), &ciphertext)?;
```

### Parameter Sets

ML-KEM supports three parameter sets, each providing a different level of security:

- `ParameterSet::ML_KEM_512`: Provides security category 1.
- `ParameterSet::ML_KEM_768`: Provides security category 3.
- `ParameterSet::ML_KEM_1024`: Provides security category 5.

The parameter set determines the size of the keys, ciphertexts, and shared secrets, as well as the computational cost of the operations.

### Error Handling

The ML-KEM functions return a `Result` type, which allows for proper error handling. The possible errors are defined in the `Error` enum and include:

- `InvalidPublicKey`: Indicates that the provided public key is invalid.
- `InvalidPrivateKey`: Indicates that the provided private key is invalid.
- `InvalidCiphertext`: Indicates that the provided ciphertext is invalid.
- `InvalidParameterSet`: Indicates that the provided parameter set is invalid.
- `RandomnessError`: Indicates an error related to randomness generation.

Make sure to handle these errors appropriately in your application.

### Security Considerations

- The shared secret generated by ML-KEM should be treated as sensitive data and handled securely.
- The private key should be kept secret and securely stored.
- Proper secure deletion techniques should be used to erase sensitive data from memory when no longer needed.
- The implementation assumes the availability of a cryptographically secure random number generator for key generation and encapsulation.
- The implementation provides constant-time operations to mitigate side-channel attacks, but additional measures may be necessary depending on the specific deployment environment.

### Performance Considerations

- The choice of parameter set affects the performance of ML-KEM operations. Higher security categories (e.g., ML-KEM-1024) require more computational resources compared to lower security categories (e.g., ML-KEM-512).
- The implementation leverages the Number-Theoretic Transform (NTT) for efficient polynomial arithmetic, which significantly improves the performance of key generation, encapsulation, and decapsulation.

### Example Usage

Here's an example that demonstrates the complete process of generating a key pair, encapsulating a shared secret, and decapsulating the shared secret:

```rust
use turtl::kem::{self, ParameterSet, KeyPair};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Generate a key pair
    let keypair = KeyPair::generate(ParameterSet::ML_KEM_768)?;
    
    // Encapsulate a shared secret
    let (ciphertext, shared_secret) = kem::encapsulate(&keypair.public_key())?;
    
    // Decapsulate the shared secret
    let decapsulated_secret = kem::decapsulate(&keypair.private_key(), &ciphertext)?;
    
    // Verify that the shared secrets match
    assert_eq!(shared_secret, decapsulated_secret);
    
    Ok(())
}
```

This example generates a key pair using the ML-KEM-768 parameter set, encapsulates a shared secret using the public key, decapsulates the shared secret using the private key, and verifies that the decapsulated secret matches the original shared secret.

For more detailed information about the ML-KEM algorithm and its specifications, please refer to NIST FIPS 203.